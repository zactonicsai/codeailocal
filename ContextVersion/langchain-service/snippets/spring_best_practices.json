[
  {
    "id": "rest-controller-best-practice",
    "category": "rest",
    "title": "REST Controller Best Practice",
    "description": "Production-grade REST controller with proper response handling, validation, and documentation",
    "code": "package com.example.api.controller;\n\nimport com.example.api.dto.ProductCreateDTO;\nimport com.example.api.dto.ProductResponseDTO;\nimport com.example.api.dto.ProductUpdateDTO;\nimport com.example.api.service.ProductService;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.Parameter;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport jakarta.validation.Valid;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.web.PageableDefault;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.UUID;\n\n/**\n * Best Practice: REST Controller\n *\n * KEY CONVENTIONS:\n * - Use @RequiredArgsConstructor for constructor injection (no @Autowired on fields).\n * - Return ResponseEntity<?> for explicit HTTP status control.\n * - Apply @Valid on request bodies to trigger Bean Validation.\n * - Keep controllers thin — delegate all business logic to the service layer.\n * - Use @Tag and @Operation for OpenAPI/Swagger documentation.\n * - Prefer UUID over Long for public-facing resource identifiers.\n * - Use @PageableDefault to set sensible pagination defaults.\n */\n@RestController\n@RequestMapping(\"/api/v1/products\")\n@RequiredArgsConstructor\n@Tag(name = \"Products\", description = \"Product management endpoints\")\npublic class ProductController {\n\n    // Best Practice: Constructor injection via Lombok — immutable, testable, no reflection.\n    private final ProductService productService;\n\n    @GetMapping\n    @Operation(summary = \"List products with pagination\")\n    public ResponseEntity<Page<ProductResponseDTO>> listProducts(\n            @PageableDefault(size = 20, sort = \"createdAt\") Pageable pageable) {\n        // Best Practice: Return Page<DTO> directly — Spring serializes pagination metadata.\n        return ResponseEntity.ok(productService.findAll(pageable));\n    }\n\n    @GetMapping(\"/{id}\")\n    @Operation(summary = \"Get a product by ID\")\n    @ApiResponse(responseCode = \"404\", description = \"Product not found\")\n    public ResponseEntity<ProductResponseDTO> getProduct(\n            @Parameter(description = \"Product UUID\") @PathVariable UUID id) {\n        return ResponseEntity.ok(productService.findById(id));\n    }\n\n    @PostMapping\n    @Operation(summary = \"Create a new product\")\n    @ApiResponse(responseCode = \"201\", description = \"Product created\")\n    public ResponseEntity<ProductResponseDTO> createProduct(\n            @Valid @RequestBody ProductCreateDTO dto) {\n        // Best Practice: Return 201 Created with the created resource.\n        ProductResponseDTO created = productService.create(dto);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n\n    @PutMapping(\"/{id}\")\n    @Operation(summary = \"Update an existing product\")\n    public ResponseEntity<ProductResponseDTO> updateProduct(\n            @PathVariable UUID id,\n            @Valid @RequestBody ProductUpdateDTO dto) {\n        return ResponseEntity.ok(productService.update(id, dto));\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @Operation(summary = \"Delete a product\")\n    @ResponseStatus(HttpStatus.NO_CONTENT)\n    public ResponseEntity<Void> deleteProduct(@PathVariable UUID id) {\n        productService.delete(id);\n        // Best Practice: Return 204 No Content for successful deletes.\n        return ResponseEntity.noContent().build();\n    }\n}"
  },
  {
    "id": "jpa-entity-best-practice",
    "category": "entity",
    "title": "JPA Entity Best Practice",
    "description": "Well-structured JPA entity with auditing, constraints, and proper equals/hashCode",
    "code": "package com.example.api.entity;\n\nimport jakarta.persistence.*;\nimport lombok.*;\nimport org.hibernate.annotations.UuidGenerator;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\n/**\n * Best Practice: JPA Entity\n *\n * KEY CONVENTIONS:\n * - Use UUID as primary key for distributed systems and API exposure safety.\n * - Never expose auto-increment IDs in public APIs (enumeration attacks).\n * - Use @EntityListeners for automatic audit timestamps.\n * - Override equals/hashCode using ONLY the business key or ID — never collections.\n * - Use BigDecimal for monetary values — never double or float.\n * - Initialize collections inline to avoid NullPointerExceptions.\n * - Use @Builder.Default for default values when using Lombok's @Builder.\n * - Add @Version for optimistic locking in concurrent environments.\n */\n@Entity\n@Table(name = \"orders\", indexes = {\n    @Index(name = \"idx_order_status\", columnList = \"status\"),\n    @Index(name = \"idx_order_customer\", columnList = \"customer_name\")\n})\n@EntityListeners(AuditingEntityListener.class)\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class Order {\n\n    @Id\n    @UuidGenerator\n    @Column(name = \"id\", updatable = false, nullable = false)\n    private UUID id;\n\n    @Column(name = \"customer_name\", nullable = false, length = 255)\n    private String customerName;\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"status\", nullable = false, length = 20)\n    @Builder.Default\n    private OrderStatus status = OrderStatus.PENDING;\n\n    // Best Practice: Always use BigDecimal for monetary values.\n    @Column(name = \"total_amount\", nullable = false, precision = 12, scale = 2)\n    private BigDecimal totalAmount;\n\n    // Best Practice: Initialize collections to avoid NPE; use @Builder.Default with Lombok.\n    @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL, orphanRemoval = true)\n    @Builder.Default\n    private List<OrderItem> items = new ArrayList<>();\n\n    // Best Practice: Audit fields are auto-populated by Spring Data JPA.\n    @CreatedDate\n    @Column(name = \"created_at\", updatable = false)\n    private Instant createdAt;\n\n    @LastModifiedDate\n    @Column(name = \"updated_at\")\n    private Instant updatedAt;\n\n    // Best Practice: Optimistic locking prevents lost updates in concurrent systems.\n    @Version\n    private Long version;\n\n    // Best Practice: equals/hashCode on ID only — stable across entity state transitions.\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Order order)) return false;\n        return id != null && id.equals(order.getId());\n    }\n\n    @Override\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n    // Best Practice: Helper method to maintain bidirectional relationship consistency.\n    public void addItem(OrderItem item) {\n        items.add(item);\n        item.setOrder(this);\n    }\n\n    public void removeItem(OrderItem item) {\n        items.remove(item);\n        item.setOrder(null);\n    }\n}"
  },
  {
    "id": "service-layer-best-practice",
    "category": "service",
    "title": "Service Layer Best Practice",
    "description": "Transactional service with proper exception handling, logging, and separation of concerns",
    "code": "package com.example.api.service;\n\nimport com.example.api.dto.UserCreateDTO;\nimport com.example.api.dto.UserResponseDTO;\nimport com.example.api.dto.UserUpdateDTO;\nimport com.example.api.entity.User;\nimport com.example.api.exception.DuplicateResourceException;\nimport com.example.api.exception.ResourceNotFoundException;\nimport com.example.api.mapper.UserMapper;\nimport com.example.api.repository.UserRepository;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.UUID;\n\n/**\n * Best Practice: Service Layer\n *\n * KEY CONVENTIONS:\n * - Mark the class @Transactional(readOnly = true) as the default; override per method.\n * - Use read-only transactions for queries — Hibernate skips dirty-checking, improving perf.\n * - Throw domain-specific exceptions (ResourceNotFoundException) rather than generic ones.\n * - Log at appropriate levels: DEBUG for flow, INFO for business events, WARN/ERROR for failures.\n * - Never return entities from services — always map to DTOs at the service boundary.\n * - Validate business rules in the service; bean validation handles structural rules.\n */\n@Slf4j\n@Service\n@RequiredArgsConstructor\n@Transactional(readOnly = true)\npublic class UserService {\n\n    private final UserRepository userRepository;\n    private final UserMapper userMapper;\n\n    public Page<UserResponseDTO> findAll(Pageable pageable) {\n        log.debug(\"Fetching users page: number={}, size={}\", pageable.getPageNumber(), pageable.getPageSize());\n        return userRepository.findAll(pageable).map(userMapper::toResponseDTO);\n    }\n\n    public UserResponseDTO findById(UUID id) {\n        log.debug(\"Fetching user by id: {}\", id);\n        // Best Practice: Use orElseThrow with a domain exception for clean 404 handling.\n        return userRepository.findById(id)\n                .map(userMapper::toResponseDTO)\n                .orElseThrow(() -> new ResourceNotFoundException(\"User\", \"id\", id));\n    }\n\n    // Best Practice: Override readOnly for write operations.\n    @Transactional\n    public UserResponseDTO create(UserCreateDTO dto) {\n        log.info(\"Creating user with email: {}\", dto.getEmail());\n\n        // Best Practice: Check uniqueness constraints BEFORE persisting to give clear error messages.\n        if (userRepository.existsByEmail(dto.getEmail())) {\n            throw new DuplicateResourceException(\"User\", \"email\", dto.getEmail());\n        }\n\n        User user = userMapper.toEntity(dto);\n        User saved = userRepository.save(user);\n        log.info(\"User created successfully: id={}\", saved.getId());\n        return userMapper.toResponseDTO(saved);\n    }\n\n    @Transactional\n    public UserResponseDTO update(UUID id, UserUpdateDTO dto) {\n        log.info(\"Updating user: id={}\", id);\n        User user = userRepository.findById(id)\n                .orElseThrow(() -> new ResourceNotFoundException(\"User\", \"id\", id));\n\n        // Best Practice: Use a mapper method for partial updates to keep code DRY.\n        userMapper.updateEntity(dto, user);\n        User saved = userRepository.save(user);\n        log.info(\"User updated successfully: id={}\", saved.getId());\n        return userMapper.toResponseDTO(saved);\n    }\n\n    @Transactional\n    public void delete(UUID id) {\n        log.info(\"Deleting user: id={}\", id);\n        if (!userRepository.existsById(id)) {\n            throw new ResourceNotFoundException(\"User\", \"id\", id);\n        }\n        userRepository.deleteById(id);\n        log.info(\"User deleted: id={}\", id);\n    }\n}"
  },
  {
    "id": "repository-best-practice",
    "category": "repo",
    "title": "Repository Best Practice",
    "description": "Spring Data JPA repository with custom queries, projections, and specifications",
    "code": "package com.example.api.repository;\n\nimport com.example.api.entity.Product;\nimport com.example.api.entity.ProductStatus;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.jpa.repository.Modifying;\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.stereotype.Repository;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.UUID;\n\n/**\n * Best Practice: Repository Layer\n *\n * KEY CONVENTIONS:\n * - Extend JpaRepository for full CRUD + pagination + flush/batch support.\n * - Extend JpaSpecificationExecutor for dynamic, type-safe queries.\n * - Return Optional for single-entity lookups — never return null.\n * - Use @Query with JPQL for complex queries; native SQL only when JPQL cannot express it.\n * - Projections (interfaces) reduce data transfer for read-heavy endpoints.\n * - Use @Modifying + @Query for bulk updates that bypass entity lifecycle (faster).\n * - Name query methods descriptively — Spring Data parses them into SQL automatically.\n */\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, UUID>,\n                                             JpaSpecificationExecutor<Product> {\n\n    // Best Practice: Derived query method — Spring Data generates the SQL at startup.\n    Optional<Product> findBySku(String sku);\n\n    boolean existsBySku(String sku);\n\n    // Best Practice: Return Page<> for endpoints that need pagination metadata.\n    Page<Product> findByStatus(ProductStatus status, Pageable pageable);\n\n    // Best Practice: Use JPQL @Query when derived method names get unwieldy.\n    @Query(\"SELECT p FROM Product p WHERE p.price BETWEEN :min AND :max AND p.status = :status\")\n    Page<Product> findByPriceRangeAndStatus(\n            @Param(\"min\") BigDecimal min,\n            @Param(\"max\") BigDecimal max,\n            @Param(\"status\") ProductStatus status,\n            Pageable pageable);\n\n    // Best Practice: Projection interface — fetches only needed columns, reducing memory footprint.\n    @Query(\"SELECT p.id AS id, p.name AS name, p.price AS price FROM Product p WHERE p.status = 'ACTIVE'\")\n    List<ProductSummaryProjection> findActiveProductSummaries();\n\n    // Best Practice: Bulk update via @Modifying bypasses Hibernate caching — always clearAutomatically.\n    @Modifying(clearAutomatically = true)\n    @Query(\"UPDATE Product p SET p.status = :status WHERE p.id IN :ids\")\n    int bulkUpdateStatus(@Param(\"ids\") List<UUID> ids, @Param(\"status\") ProductStatus status);\n\n    // Best Practice: Native query only when JPQL lacks a needed DB feature (e.g., full-text search).\n    @Query(value = \"SELECT * FROM products p WHERE to_tsvector('english', p.name || ' ' || p.description) @@ plainto_tsquery('english', :term)\",\n           nativeQuery = true)\n    List<Product> fullTextSearch(@Param(\"term\") String searchTerm);\n\n    /**\n     * Projection interface — defines the shape of a lightweight read model.\n     * Spring Data implements this at runtime; no mapping code needed.\n     */\n    interface ProductSummaryProjection {\n        UUID getId();\n        String getName();\n        BigDecimal getPrice();\n    }\n}"
  },
  {
    "id": "dto-mapper-best-practice",
    "category": "dto",
    "title": "DTO + MapStruct Mapper Best Practice",
    "description": "Clean DTO separation with validation and MapStruct mapping",
    "code": "package com.example.api.dto;\n\nimport jakarta.validation.constraints.*;\nimport lombok.*;\n\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.util.UUID;\n\n/**\n * Best Practice: DTO Layer\n *\n * KEY CONVENTIONS:\n * - Separate DTOs for Create, Update, and Response — each has different field requirements.\n * - CreateDTO: Carries only the fields the client must provide; heavy validation.\n * - UpdateDTO: Fields are nullable — only non-null fields trigger updates (partial update).\n * - ResponseDTO: Carries only fields safe for external exposure; never includes passwords, internal IDs.\n * - Use Java records for immutable DTOs where Lombok is not needed.\n * - Apply Bean Validation annotations to enforce structural rules at the controller boundary.\n */\n\n// === CREATE DTO — used for POST requests ===\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class CustomerCreateDTO {\n\n    @NotBlank(message = \"First name is required\")\n    @Size(min = 1, max = 100, message = \"First name must be between 1 and 100 characters\")\n    private String firstName;\n\n    @NotBlank(message = \"Last name is required\")\n    @Size(min = 1, max = 100)\n    private String lastName;\n\n    @NotBlank(message = \"Email is required\")\n    @Email(message = \"Must be a valid email address\")\n    private String email;\n\n    @Pattern(regexp = \"^\\\\+?[1-9]\\\\d{1,14}$\", message = \"Must be a valid phone number\")\n    private String phone;\n\n    @Valid  // Best Practice: @Valid triggers nested DTO validation.\n    @NotNull(message = \"Address is required\")\n    private AddressDTO address;\n}\n\n// === UPDATE DTO — used for PUT/PATCH; all fields nullable for partial updates ===\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class CustomerUpdateDTO {\n\n    @Size(min = 1, max = 100)\n    private String firstName;\n\n    @Size(min = 1, max = 100)\n    private String lastName;\n\n    @Email\n    private String email;\n\n    private String phone;\n\n    @Valid\n    private AddressDTO address;\n}\n\n// === RESPONSE DTO — used for API responses; only exposes safe fields ===\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class CustomerResponseDTO {\n    private UUID id;\n    private String firstName;\n    private String lastName;\n    private String email;\n    private String phone;\n    private AddressDTO address;\n    private Instant createdAt;\n    private Instant updatedAt;\n}\n\n// === Nested DTO ===\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class AddressDTO {\n    @NotBlank private String street;\n    @NotBlank private String city;\n    @NotBlank private String state;\n    @NotBlank private String zipCode;\n    @NotBlank private String country;\n}\n\n// ═══════════════════════════════════════\n// MapStruct Mapper\n// ═══════════════════════════════════════\npackage com.example.api.mapper;\n\nimport com.example.api.dto.*;\nimport com.example.api.entity.Customer;\nimport org.mapstruct.*;\n\n/**\n * Best Practice: MapStruct Mapper\n *\n * KEY CONVENTIONS:\n * - Use componentModel = \"spring\" to make it a Spring bean (injectable).\n * - NullValuePropertyMappingStrategy.IGNORE enables partial updates — null fields are skipped.\n * - Define explicit @Mapping only when field names differ between DTO and entity.\n * - Use @MappingTarget for in-place entity updates to preserve JPA managed state.\n */\n@Mapper(componentModel = \"spring\",\n        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)\npublic interface CustomerMapper {\n\n    CustomerResponseDTO toResponseDTO(Customer entity);\n\n    @Mapping(target = \"id\", ignore = true)\n    @Mapping(target = \"createdAt\", ignore = true)\n    @Mapping(target = \"updatedAt\", ignore = true)\n    Customer toEntity(CustomerCreateDTO dto);\n\n    // Best Practice: @MappingTarget updates the existing entity in-place,\n    // preserving Hibernate's managed state and dirty-checking.\n    @Mapping(target = \"id\", ignore = true)\n    @Mapping(target = \"createdAt\", ignore = true)\n    @Mapping(target = \"updatedAt\", ignore = true)\n    void updateEntity(CustomerUpdateDTO dto, @MappingTarget Customer entity);\n}"
  },
  {
    "id": "security-config-best-practice",
    "category": "security",
    "title": "Spring Security JWT Configuration Best Practice",
    "description": "Modern SecurityFilterChain configuration with JWT, CORS, and role-based access",
    "code": "package com.example.api.config;\n\nimport com.example.api.security.JwtAuthenticationFilter;\nimport com.example.api.security.JwtAuthenticationEntryPoint;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\nimport java.util.List;\n\n/**\n * Best Practice: Spring Security Configuration\n *\n * KEY CONVENTIONS:\n * - Use SecurityFilterChain bean (not deprecated WebSecurityConfigurerAdapter).\n * - Stateless sessions for REST APIs — JWT replaces server-side session state.\n * - Disable CSRF for stateless APIs (CSRF protection is for cookie-based sessions).\n * - Enable CORS with explicit origins — never use allowedOrigins(\"*\") in production.\n * - BCrypt with strength >= 12 for password hashing.\n * - @EnableMethodSecurity enables @PreAuthorize on controller/service methods.\n * - Custom AuthenticationEntryPoint returns JSON 401 instead of redirect to login page.\n * - Place JWT filter BEFORE UsernamePasswordAuthenticationFilter in the chain.\n */\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity  // Best Practice: Enables @PreAuthorize, @Secured, @RolesAllowed\n@RequiredArgsConstructor\npublic class SecurityConfig {\n\n    private final JwtAuthenticationFilter jwtFilter;\n    private final JwtAuthenticationEntryPoint entryPoint;\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        return http\n            // Best Practice: Disable CSRF for stateless JWT-based APIs.\n            .csrf(csrf -> csrf.disable())\n            .cors(cors -> cors.configurationSource(corsConfigurationSource()))\n\n            // Best Practice: STATELESS — no HttpSession created or used.\n            .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n\n            // Best Practice: Custom entry point returns JSON error, not a redirect.\n            .exceptionHandling(ex -> ex.authenticationEntryPoint(entryPoint))\n\n            .authorizeHttpRequests(auth -> auth\n                // Public endpoints\n                .requestMatchers(\"/api/v1/auth/**\").permitAll()\n                .requestMatchers(\"/actuator/health\").permitAll()\n                .requestMatchers(\"/v3/api-docs/**\", \"/swagger-ui/**\").permitAll()\n\n                // Role-based access\n                .requestMatchers(HttpMethod.DELETE, \"/api/v1/**\").hasRole(\"ADMIN\")\n\n                // Everything else requires authentication\n                .anyRequest().authenticated()\n            )\n\n            // Best Practice: Insert JWT filter before the default username/password filter.\n            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)\n            .build();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        // Best Practice: BCrypt with strength 12 — good balance of security and performance.\n        return new BCryptPasswordEncoder(12);\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManager(\n            AuthenticationConfiguration config) throws Exception {\n        return config.getAuthenticationManager();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration config = new CorsConfiguration();\n        // Best Practice: Whitelist explicit origins in production.\n        config.setAllowedOrigins(List.of(\"http://localhost:3000\", \"https://yourdomain.com\"));\n        config.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\n        config.setAllowedHeaders(List.of(\"Authorization\", \"Content-Type\"));\n        config.setAllowCredentials(true);\n        config.setMaxAge(3600L);\n\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/api/**\", config);\n        return source;\n    }\n}"
  },
  {
    "id": "unit-test-best-practice",
    "category": "test",
    "title": "Unit Test Best Practice with JUnit 5 + Mockito",
    "description": "Comprehensive unit tests with mocking, edge cases, and clear structure",
    "code": "package com.example.api.service;\n\nimport com.example.api.dto.UserCreateDTO;\nimport com.example.api.dto.UserResponseDTO;\nimport com.example.api.entity.User;\nimport com.example.api.exception.DuplicateResourceException;\nimport com.example.api.exception.ResourceNotFoundException;\nimport com.example.api.mapper.UserMapper;\nimport com.example.api.repository.UserRepository;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Optional;\nimport java.util.UUID;\n\nimport static org.assertj.core.api.Assertions.*;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.BDDMockito.given;\nimport static org.mockito.Mockito.*;\n\n/**\n * Best Practice: Unit Testing with JUnit 5 + Mockito\n *\n * KEY CONVENTIONS:\n * - Use @ExtendWith(MockitoExtension.class) — lightweight, no Spring context loaded.\n * - BDD style: given(...).willReturn(...) reads like a specification.\n * - Use @Nested classes to group tests by method under test.\n * - @DisplayName makes test reports human-readable.\n * - AssertJ assertions are more readable and powerful than JUnit's assertEquals.\n * - Test the happy path AND edge cases (not found, duplicate, null input).\n * - Verify side effects (e.g., repository.save was called) with verify().\n * - Never test implementation details — test behaviour and outcomes.\n */\n@ExtendWith(MockitoExtension.class)\n@DisplayName(\"UserService Unit Tests\")\nclass UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Mock\n    private UserMapper userMapper;\n\n    @InjectMocks\n    private UserService userService;\n\n    // Best Practice: Shared test fixtures as constants.\n    private static final UUID USER_ID = UUID.fromString(\"550e8400-e29b-41d4-a716-446655440000\");\n    private static final String USER_EMAIL = \"john@example.com\";\n\n    @Nested\n    @DisplayName(\"findById\")\n    class FindById {\n\n        @Test\n        @DisplayName(\"should return user when found\")\n        void shouldReturnUserWhenFound() {\n            // Given\n            User user = User.builder().id(USER_ID).email(USER_EMAIL).build();\n            UserResponseDTO expectedDto = UserResponseDTO.builder().id(USER_ID).email(USER_EMAIL).build();\n\n            given(userRepository.findById(USER_ID)).willReturn(Optional.of(user));\n            given(userMapper.toResponseDTO(user)).willReturn(expectedDto);\n\n            // When\n            UserResponseDTO result = userService.findById(USER_ID);\n\n            // Then — AssertJ assertions are more expressive.\n            assertThat(result)\n                .isNotNull()\n                .satisfies(dto -> {\n                    assertThat(dto.getId()).isEqualTo(USER_ID);\n                    assertThat(dto.getEmail()).isEqualTo(USER_EMAIL);\n                });\n        }\n\n        @Test\n        @DisplayName(\"should throw ResourceNotFoundException when not found\")\n        void shouldThrowWhenNotFound() {\n            // Given\n            given(userRepository.findById(USER_ID)).willReturn(Optional.empty());\n\n            // When / Then — assertThatThrownBy is cleaner than @Test(expected=...)\n            assertThatThrownBy(() -> userService.findById(USER_ID))\n                .isInstanceOf(ResourceNotFoundException.class)\n                .hasMessageContaining(USER_ID.toString());\n        }\n    }\n\n    @Nested\n    @DisplayName(\"create\")\n    class Create {\n\n        @Test\n        @DisplayName(\"should create user successfully\")\n        void shouldCreateSuccessfully() {\n            // Given\n            UserCreateDTO dto = UserCreateDTO.builder().email(USER_EMAIL).build();\n            User user = User.builder().email(USER_EMAIL).build();\n            User savedUser = User.builder().id(USER_ID).email(USER_EMAIL).build();\n            UserResponseDTO responseDto = UserResponseDTO.builder().id(USER_ID).email(USER_EMAIL).build();\n\n            given(userRepository.existsByEmail(USER_EMAIL)).willReturn(false);\n            given(userMapper.toEntity(dto)).willReturn(user);\n            given(userRepository.save(user)).willReturn(savedUser);\n            given(userMapper.toResponseDTO(savedUser)).willReturn(responseDto);\n\n            // When\n            UserResponseDTO result = userService.create(dto);\n\n            // Then\n            assertThat(result.getId()).isEqualTo(USER_ID);\n            // Best Practice: Verify the save was called exactly once.\n            verify(userRepository, times(1)).save(any(User.class));\n        }\n\n        @Test\n        @DisplayName(\"should throw DuplicateResourceException for existing email\")\n        void shouldThrowOnDuplicateEmail() {\n            // Given\n            UserCreateDTO dto = UserCreateDTO.builder().email(USER_EMAIL).build();\n            given(userRepository.existsByEmail(USER_EMAIL)).willReturn(true);\n\n            // When / Then\n            assertThatThrownBy(() -> userService.create(dto))\n                .isInstanceOf(DuplicateResourceException.class);\n\n            // Best Practice: Verify save was NEVER called when validation fails.\n            verify(userRepository, never()).save(any());\n        }\n    }\n}"
  },
  {
    "id": "exception-handler-best-practice",
    "category": "exception",
    "title": "Global Exception Handler Best Practice",
    "description": "Centralized error handling with structured responses and proper logging",
    "code": "package com.example.api.exception;\n\nimport lombok.*;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.validation.FieldError;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\nimport org.springframework.web.context.request.WebRequest;\n\nimport java.time.Instant;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Best Practice: Global Exception Handler\n *\n * KEY CONVENTIONS:\n * - @RestControllerAdvice centralizes ALL exception-to-HTTP-response mapping.\n * - Return a structured ErrorResponse DTO — never expose raw stack traces to clients.\n * - Log server errors (5xx) at ERROR level; client errors (4xx) at WARN level.\n * - Map validation errors into a field-level details map for frontend consumption.\n * - Order handlers from most specific to most general.\n * - Include a catch-all for unexpected exceptions — return 500 with a generic message.\n * - Include the request path in the error response for easier debugging.\n */\n@Slf4j\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    // === Structured Error Response DTO ===\n    @Data\n    @Builder\n    @AllArgsConstructor\n    public static class ErrorResponse {\n        private Instant timestamp;\n        private int status;\n        private String error;\n        private String message;\n        private String path;\n        private Map<String, String> details;\n    }\n\n    // Best Practice: Domain-specific 404 exception.\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex, WebRequest request) {\n        log.warn(\"Resource not found: {}\", ex.getMessage());\n        return buildResponse(HttpStatus.NOT_FOUND, ex.getMessage(), request);\n    }\n\n    // Best Practice: Domain-specific 409 Conflict for duplicates.\n    @ExceptionHandler(DuplicateResourceException.class)\n    public ResponseEntity<ErrorResponse> handleDuplicate(DuplicateResourceException ex, WebRequest request) {\n        log.warn(\"Duplicate resource: {}\", ex.getMessage());\n        return buildResponse(HttpStatus.CONFLICT, ex.getMessage(), request);\n    }\n\n    // Best Practice: Map Bean Validation errors into per-field detail messages.\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex, WebRequest request) {\n        Map<String, String> fieldErrors = new HashMap<>();\n        for (FieldError error : ex.getBindingResult().getFieldErrors()) {\n            fieldErrors.put(error.getField(), error.getDefaultMessage());\n        }\n        log.warn(\"Validation failed: {} field errors\", fieldErrors.size());\n\n        ErrorResponse body = ErrorResponse.builder()\n                .timestamp(Instant.now())\n                .status(HttpStatus.BAD_REQUEST.value())\n                .error(\"Validation Failed\")\n                .message(\"One or more fields have invalid values\")\n                .path(request.getDescription(false).replace(\"uri=\", \"\"))\n                .details(fieldErrors)\n                .build();\n\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(body);\n    }\n\n    // Best Practice: Illegal argument → 400 Bad Request.\n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity<ErrorResponse> handleBadRequest(IllegalArgumentException ex, WebRequest request) {\n        log.warn(\"Bad request: {}\", ex.getMessage());\n        return buildResponse(HttpStatus.BAD_REQUEST, ex.getMessage(), request);\n    }\n\n    // Best Practice: Catch-all — log at ERROR, return generic message (never expose internals).\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity<ErrorResponse> handleAll(Exception ex, WebRequest request) {\n        log.error(\"Unexpected error: \", ex);\n        return buildResponse(HttpStatus.INTERNAL_SERVER_ERROR,\n                \"An unexpected error occurred. Please try again later.\", request);\n    }\n\n    private ResponseEntity<ErrorResponse> buildResponse(HttpStatus status, String message, WebRequest request) {\n        ErrorResponse body = ErrorResponse.builder()\n                .timestamp(Instant.now())\n                .status(status.value())\n                .error(status.getReasonPhrase())\n                .message(message)\n                .path(request.getDescription(false).replace(\"uri=\", \"\"))\n                .build();\n        return ResponseEntity.status(status).body(body);\n    }\n}\n\n// === Custom Exception Classes ===\npackage com.example.api.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n/**\n * Best Practice: Domain exception with formatted message for API consumers.\n */\n@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class ResourceNotFoundException extends RuntimeException {\n    public ResourceNotFoundException(String resource, String field, Object value) {\n        super(String.format(\"%s not found with %s: '%s'\", resource, field, value));\n    }\n}\n\n@ResponseStatus(HttpStatus.CONFLICT)\npublic class DuplicateResourceException extends RuntimeException {\n    public DuplicateResourceException(String resource, String field, Object value) {\n        super(String.format(\"%s already exists with %s: '%s'\", resource, field, value));\n    }\n}"
  },
  {
    "id": "application-config-best-practice",
    "category": "config",
    "title": "Application Configuration Best Practice",
    "description": "Spring Boot application.yml with profiles, actuator, and externalized config",
    "code": "# Best Practice: application.yml Configuration\n#\n# KEY CONVENTIONS:\n# - Use YAML over properties for readability and hierarchy.\n# - Externalize secrets via environment variables: ${DB_PASSWORD}\n# - Enable JPA auditing with @EnableJpaAuditing on a @Configuration class.\n# - Set ddl-auto to 'validate' in production — use Flyway/Liquibase for migrations.\n# - Enable actuator health endpoint but restrict sensitive endpoints.\n# - Set sensible connection pool defaults (HikariCP).\n# - Use profiles (dev, staging, prod) for environment-specific overrides.\n\nspring:\n  application:\n    name: my-service\n\n  # --- Database ---\n  datasource:\n    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:mydb}\n    username: ${DB_USERNAME:postgres}\n    password: ${DB_PASSWORD}\n    hikari:\n      maximum-pool-size: 20          # Best Practice: Size pool to ~2x CPU cores.\n      minimum-idle: 5\n      idle-timeout: 300000           # 5 minutes\n      connection-timeout: 20000      # 20 seconds — fail fast on connection issues.\n      max-lifetime: 1800000          # 30 minutes — recycle connections before DB timeout.\n\n  jpa:\n    hibernate:\n      ddl-auto: validate             # Best Practice: NEVER use 'update' or 'create' in prod.\n    open-in-view: false              # Best Practice: Disable OSIV to avoid lazy-loading in views.\n    properties:\n      hibernate:\n        format_sql: true\n        default_batch_fetch_size: 16  # Best Practice: Batch fetch to mitigate N+1 queries.\n\n  # --- Jackson ---\n  jackson:\n    default-property-inclusion: non_null   # Best Practice: Don't serialize null fields.\n    serialization:\n      write-dates-as-timestamps: false     # Best Practice: ISO-8601 date strings.\n\n# --- Server ---\nserver:\n  port: ${SERVER_PORT:8080}\n  shutdown: graceful                       # Best Practice: Allow in-flight requests to complete.\n  servlet:\n    context-path: /\n\n# --- Actuator ---\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info,metrics,prometheus\n  endpoint:\n    health:\n      show-details: when-authorized         # Best Practice: Hide details from unauthenticated users.\n\n# --- Logging ---\nlogging:\n  level:\n    com.example: DEBUG                      # Your app — verbose in dev, INFO in prod.\n    org.springframework.security: WARN\n    org.hibernate.SQL: DEBUG\n    org.hibernate.type.descriptor.sql: TRACE  # Logs bind parameter values."
  },
  {
    "id": "integration-test-best-practice",
    "category": "test",
    "title": "Integration Test with @SpringBootTest and Testcontainers",
    "description": "Full integration test using real database via Testcontainers",
    "code": "package com.example.api;\n\nimport com.example.api.dto.ProductCreateDTO;\nimport com.example.api.dto.ProductResponseDTO;\nimport com.example.api.entity.ProductStatus;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.context.ActiveProfiles;\nimport org.testcontainers.containers.PostgreSQLContainer;\nimport org.testcontainers.junit.jupiter.Container;\nimport org.testcontainers.junit.jupiter.Testcontainers;\n\nimport java.math.BigDecimal;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Best Practice: Integration Testing\n *\n * KEY CONVENTIONS:\n * - @Testcontainers + @Container spins up a real PostgreSQL instance per test class.\n * - @ServiceConnection auto-configures datasource from the container — no manual URL wiring.\n * - Use @SpringBootTest(webEnvironment = RANDOM_PORT) to test the full HTTP stack.\n * - TestRestTemplate tests the REAL serialization, validation, and error handling pipeline.\n * - @ActiveProfiles(\"test\") loads test-specific config (e.g., lower pool sizes).\n * - Test the contract: HTTP status codes, response structure, and side effects.\n * - This tests what unit tests cannot: wiring, transactions, DB constraints, and serialization.\n */\n@Testcontainers\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@ActiveProfiles(\"test\")\n@DisplayName(\"Product API Integration Tests\")\nclass ProductApiIntegrationTest {\n\n    @Container\n    @ServiceConnection\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:16-alpine\");\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    @DisplayName(\"POST /api/v1/products should create and return 201\")\n    void createProduct_shouldReturn201() {\n        // Given\n        ProductCreateDTO dto = ProductCreateDTO.builder()\n                .name(\"Widget\")\n                .sku(\"WDG-001\")\n                .price(new BigDecimal(\"29.99\"))\n                .build();\n\n        // When\n        ResponseEntity<ProductResponseDTO> response = restTemplate.postForEntity(\n                \"/api/v1/products\", dto, ProductResponseDTO.class);\n\n        // Then\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);\n        assertThat(response.getBody()).isNotNull();\n        assertThat(response.getBody().getId()).isNotNull();\n        assertThat(response.getBody().getName()).isEqualTo(\"Widget\");\n    }\n\n    @Test\n    @DisplayName(\"POST /api/v1/products with missing name should return 400\")\n    void createProduct_withoutName_shouldReturn400() {\n        // Given — missing required field\n        ProductCreateDTO dto = ProductCreateDTO.builder()\n                .sku(\"WDG-002\")\n                .price(new BigDecimal(\"19.99\"))\n                .build();\n\n        // When\n        ResponseEntity<String> response = restTemplate.postForEntity(\n                \"/api/v1/products\", dto, String.class);\n\n        // Then\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\n    }\n\n    @Test\n    @DisplayName(\"GET /api/v1/products/{id} with invalid ID should return 404\")\n    void getProduct_notFound_shouldReturn404() {\n        // When\n        ResponseEntity<String> response = restTemplate.getForEntity(\n                \"/api/v1/products/00000000-0000-0000-0000-000000000000\", String.class);\n\n        // Then\n        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);\n    }\n}"
  },
  {
    "id": "event-driven-best-practice",
    "category": "service",
    "title": "Application Events Best Practice",
    "description": "Decoupled event-driven architecture using Spring's ApplicationEventPublisher",
    "code": "package com.example.api.event;\n\nimport lombok.*;\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.event.TransactionPhase;\nimport org.springframework.transaction.event.TransactionalEventListener;\n\nimport java.util.UUID;\n\n/**\n * Best Practice: Application Events\n *\n * KEY CONVENTIONS:\n * - Use Spring events to decouple domain actions from side effects (email, audit, cache).\n * - Use record for immutable event payloads (Java 17+).\n * - @TransactionalEventListener(AFTER_COMMIT) ensures the listener runs only if the\n *   transaction succeeds — prevents sending emails for rolled-back orders.\n * - @Async offloads non-critical work (email, notifications) to a separate thread pool.\n * - Never put critical business logic in event listeners — they are for side effects.\n * - This pattern replaces tight coupling like: orderService calling emailService directly.\n */\n\n// === Event Record (immutable payload) ===\npublic record OrderCreatedEvent(\n    UUID orderId,\n    String customerEmail,\n    java.math.BigDecimal totalAmount\n) {}\n\n// === Publishing events from the service ===\n@Service\n@RequiredArgsConstructor\npublic class OrderService {\n\n    private final OrderRepository orderRepository;\n    private final ApplicationEventPublisher eventPublisher;\n\n    @Transactional\n    public OrderResponseDTO create(OrderCreateDTO dto) {\n        Order order = orderMapper.toEntity(dto);\n        Order saved = orderRepository.save(order);\n\n        // Best Practice: Publish event INSIDE the transaction boundary.\n        // The @TransactionalEventListener controls WHEN the listener actually runs.\n        eventPublisher.publishEvent(new OrderCreatedEvent(\n            saved.getId(), saved.getCustomerEmail(), saved.getTotalAmount()\n        ));\n\n        return orderMapper.toResponseDTO(saved);\n    }\n}\n\n// === Listening for events ===\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class OrderEventListener {\n\n    private final EmailService emailService;\n    private final AuditService auditService;\n\n    // Best Practice: AFTER_COMMIT — only runs if the order was actually persisted.\n    @Async\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\n    public void handleOrderCreated(OrderCreatedEvent event) {\n        log.info(\"Processing OrderCreatedEvent for order: {}\", event.orderId());\n\n        // Non-critical: failure here does NOT roll back the order.\n        emailService.sendOrderConfirmation(event.customerEmail(), event.orderId());\n        auditService.logOrderCreation(event.orderId(), event.totalAmount());\n    }\n}"
  },
  {
    "id": "caching-best-practice",
    "category": "config",
    "title": "Spring Cache Best Practice",
    "description": "Declarative caching with proper eviction and cache key strategies",
    "code": "package com.example.api.config;\n\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.cache.RedisCacheConfiguration;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.RedisSerializationContext;\n\nimport java.time.Duration;\nimport java.util.Map;\n\n/**\n * Best Practice: Spring Cache with Redis\n *\n * KEY CONVENTIONS:\n * - @EnableCaching activates Spring's cache abstraction via proxies.\n * - Configure per-cache TTLs — \"products\" cache may have a different TTL than \"users\".\n * - Use JSON serialization so cache entries are human-readable and debuggable.\n * - @Cacheable on READ methods, @CacheEvict on WRITE methods.\n * - @CachePut forces a cache update (useful when you want to refresh after an update).\n * - Use SpEL for cache keys: @Cacheable(key = \"#id\") instead of relying on default toString.\n * - Disable caching in tests: spring.cache.type=none in test profile.\n */\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n\n    @Bean\n    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {\n        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofMinutes(30))\n                .serializeValuesWith(\n                    RedisSerializationContext.SerializationPair.fromSerializer(\n                        new GenericJackson2JsonRedisSerializer()));\n\n        // Best Practice: Per-cache TTL configuration.\n        Map<String, RedisCacheConfiguration> cacheConfigs = Map.of(\n            \"products\", defaultConfig.entryTtl(Duration.ofMinutes(60)),\n            \"users\",    defaultConfig.entryTtl(Duration.ofMinutes(15)),\n            \"config\",   defaultConfig.entryTtl(Duration.ofHours(24))\n        );\n\n        return RedisCacheManager.builder(connectionFactory)\n                .cacheDefaults(defaultConfig)\n                .withInitialCacheConfigurations(cacheConfigs)\n                .build();\n    }\n}\n\n// === Usage in Service ===\n// @Cacheable(value = \"products\", key = \"#id\")\n// public ProductResponseDTO findById(UUID id) { ... }\n//\n// @CacheEvict(value = \"products\", key = \"#id\")\n// public void delete(UUID id) { ... }\n//\n// @CachePut(value = \"products\", key = \"#id\")\n// public ProductResponseDTO update(UUID id, ProductUpdateDTO dto) { ... }"
  }
]
